//
//  HIPAPIError+FastTesting.swift
//  Pods
//
//  Created by Karasuluoglu on 28.10.2020.
//

import Foundation

/// <note> This class can be used to test the different error UI scenarios locally without any need for an API response.
public class HIPAPIErrorGenerator {
    private var type: String?
    private var nonFieldMessages: [String] = []
    private var fields: [HIPAPIErrorField] = []
    private var fallbackMessage: String?

    public init() { }

    public func setType(_ type: String = "Some Type") -> Self {
        self.type = type
        return self
    }

    public func setNonField(_ generation: NonFieldGeneration) -> Self {
        switch generation {
        case .autoGenerated(let message):
            switch message {
            case .single:
                nonFieldMessages = ["Some Non-Field Message"]
            case .multiple(let count):
                nonFieldMessages = (0..<count).map { "Some Non-Field Message \($0)" }
            }
        case .explicit(let messages):
            nonFieldMessages = messages
        }
        return self
    }

    public func setFields(_ generation: FieldGeneration) -> Self {
        switch generation {
        case .autoGenerated(let autoGeneratedFields):
            var transformedFields: [HIPAPIErrorField] = []
            for (index, field) in autoGeneratedFields.enumerated() {
                transformedFields.append(transform(field, identifier: "\(index + 1)"))
            }
            fields = transformedFields
        case .explicit(let explicitFields):
            fields = explicitFields.map(transform)
        }
        return self
    }

    public func setFallbackMessage(_ fallbackMessage: String = "Some Fallback Message") -> Self {
        self.fallbackMessage = fallbackMessage
        return self
    }

    public func generate() -> HIPAPIError {
        return HIPAPIError(
            type: type,
            detail: HIPAPIErrorDetail(
                nonFieldMessages: nonFieldMessages,
                fields: fields
            ),
            fallbackMessage: fallbackMessage
        )
    }
}

extension HIPAPIErrorGenerator {
    private func transform(_ field: AutoGeneratedField, identifier: String) -> HIPAPIErrorField {
        switch field {
            case .root(let message):
                let transformedMessages: [String]
                switch message {
                    case .single:
                        transformedMessages = ["Some Field Message \(identifier)"]
                    case .multiple(let count):
                        transformedMessages = (0..<count).map { "Some Field Message \(identifier)-\($0)" }
                }
                return HIPAPIErrorField(
                    name: "Some Field Name \(identifier)",
                    detail: .messages(transformedMessages)
                )
            case .nested(let nestedFields):
                var transformedNestedFields: [HIPAPIErrorField] = []
                for (nestedIndex, nestedField) in nestedFields.enumerated() {
                    transformedNestedFields.append(transform(nestedField, identifier: "\(identifier)-\(nestedIndex + 1)"))
                }
                return HIPAPIErrorField(
                    name: "Some Field Name \(identifier)",
                    detail: .subfields(transformedNestedFields)
                )
        }
    }

    private func transform(_ field: ExplicitField) -> HIPAPIErrorField {
        switch field {
        case .root(let name, let messages):
            return HIPAPIErrorField(
                name: name,
                detail: .messages(messages)
            )
        case .nested(let name, let subfields):
            return HIPAPIErrorField(
                name: name,
                detail: .subfields(subfields.map(transform))
            )
        }
    }
}

extension HIPAPIErrorGenerator {
    public enum NonFieldGeneration: ExpressibleByStringLiteral {
        case autoGenerated(AutoGeneratedMessage)
        case explicit([String])

        public init(stringLiteral value: String) {
            self = .explicit([value])
        }
    }

    public enum FieldGeneration {
        case autoGenerated([AutoGeneratedField])
        case explicit([ExplicitField])
    }

    public enum AutoGeneratedField {
        case root(AutoGeneratedMessage)
        case nested([AutoGeneratedField])
    }

    public enum ExplicitField {
        case root(name: String, messages: [String])
        case nested(name: String, subfields: [ExplicitField])
    }

    public enum AutoGeneratedMessage {
        case single
        case multiple(count: Int)
    }
}
